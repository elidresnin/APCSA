// Class: GraphicsPanel
// Written by: Mr. Swope
// Date: 1/27/2020
// Description: This class is the main class for this project.  It extends the Jpanel class and will be drawn on
// 				on the JPanel in the GraphicsMain class.  
//
// Since you will modify this class you should add comments that describe when and how you modified the class.  

import java.awt.Color;
import java.util.HashMap;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.util.ArrayList;

import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.swing.JPanel;
import javax.swing.Timer;

public class GraphicsPanel extends JPanel implements KeyListener{

	private Timer timer;					// The timer is used to move objects at a consistent time interval.

	private Background background1;			// The background object will display a picture in the background.
	private Background background2;			// There has to be two background objects for scrolling.
	private Counter counter1;
	private Counter counter2;


	private Sprite sprite;					// create a Sprite object
	private Item soup;
	private Item syrup;
	private Item whisk;
	// This declares an Item object. You can make a Item display
	// pretty much any image that you would like by passing it
	// the path for the image.
	private ArrayList<Item> items;
	private int boxCounter;
	//	private Item[] randItems;
	private HashMap<Integer,Item> randItems;
	private Item movingTomato;
	private Hand hand;

	private int rand;
	private int gameScreen;
	private int titleScreenCounter;
	private int groundLevel;
	private int tomatoCounter;
	private int[] handPoint;

	private boolean move;
	private boolean whiskMove;
	private boolean tomato;


	public GraphicsPanel(){
		background1 = new Background();	// You can set the background variable equal to an instance of any of  
		background2 = new Background(-background1.getImage().getIconWidth());		
		counter1 = new Counter();	// You can set the background variable equal to an instance of any of  
		counter2 = new Counter(-counter1.getImage().getIconWidth());		

		/*
		 * Instansiates all of our obstacles
		 */
		soup = new Item(1500, 480, "images/objects/Soup.png", 1);  
		syrup = new Item(1500, 450, "images/objects/Syrup.png", 1);  
		whisk = new Item(1500, 300, "images/objects/Whisk.png", 1);  

		randItems = new HashMap<Integer,Item>();
		
		


		randItems.put(0, soup);
		randItems.put(1, syrup);
		randItems.put(2, whisk);

		movingTomato = new Item(1500, 480, "images/objects/Soup.png", 1);


		rand = 0;
		gameScreen = 1;
		groundLevel = 432;
		handPoint = new int[2];


		// The Item constructor has 4 parameters - the x coordinate, y coordinate
		// the path for the image, and the scale. The scale is used to make the
		// image smaller, so the bigger the scale, the smaller the image will be.
		items = new ArrayList<Item>();

		sprite = new Sprite(900, 432);			
		// The Sprite constuctor has two parameter - - the x coordinate and y coordinate

		setPreferredSize(new Dimension(background1.getImage().getIconWidth(),
				background2.getImage().getIconHeight()));  
		// This line of code sets the dimension of the panel equal to the dimensions
		// of the background image.

		timer = new Timer(24, new ClockListener(this));   // This object will call the ClockListener's
		// action performed method every 15 milliseconds once the 
		// timer is started. You can change how frequently this
		// method is called by changing the first parameter.

		boxCounter = 0;
		titleScreenCounter = 0;
		tomatoCounter = 0;

		move = true;
		whiskMove = false;
		tomato = false;
		

		timer.start();
		this.setFocusable(true);					     // for keylistener
		this.addKeyListener(this);
	}

	// method: paintComponent
	// description: This method will paint the items onto the graphics panel.  This method is called when the panel is
	//   			first rendered.  It can also be called by this.repaint(). You'll want to draw each of your objects.
	//				This is the only place that you can draw objects.
	// parameters: Graphics g - This object is used to draw your images onto the graphics panel.
	public void paintComponent(Graphics g){
		Graphics2D g2 = (Graphics2D) g;
		switch(gameScreen) {
			case 1:
				new Titlescreen("images/objects/Cutscene.png",1).draw(this, g);
				break;
			case 2:
				new Titlescreen("images/objects/titleScreen.png",1).draw(this, g);
				break;
			case 3:
				background1.draw(this, g);
				background2.draw(this, g);
				counter1.draw(this, g);
				counter2.draw(this, g);
				sprite.draw(g2, this);
				break;
			case 4:
				for(int i = items.size()-1; i >= 0; i--)
					items.remove(i);
				new Titlescreen("images/objects/GameOver.png",1).draw(this, g);
				playSound("sounds/GameOver.mp3");
				break;
		}


		for(int i = 0; i < items.size(); i++) {
			if(items.get(i) != null)
				items.get(i).draw(g2, this);
		}

	}

	// method:clock
	// description: This method is called by the clocklistener every 5 milliseconds.  You should update the coordinates
	//				of one of your characters in this method so that it moves as time changes.  After you update the
	//				coordinates you should repaint the panel. 
	public void clock(){
		rand = 1;
		
		
		fixPosition();

			
		whiskMove = true;
		if(gameScreen == 1)
			titleScreenCounter++;
		if(titleScreenCounter == 208) {
			gameScreen = 2;
			titleScreenCounter++;
		}



		sprite.move(this);





		boxCounter++;
		if(boxCounter % 100 == 0 && gameScreen == 3) {
			items.add(randItems.get(rand));
			items.get(items.size()-1).x_coordinate = 3000;
			System.out.println(randItems.get(rand).getX());
		}

		if(boxCounter % 1234 == 0 && gameScreen == 3) {
			items.add(new Item(3000, (int)(Math.random()*400+200), "images/objects/Tomato.png"));
		}

		// You can also check to see if two objects intersect like this. In this case if the sprite collides with the
		// item, the item will get smaller. 
		//		if(sprite.collision(item) && sprite.getY() < item.getY()) {
		//			System.out.println("stop");
		//			sprite.stop_Vertical();
		//		}


		for(Item i: items) {
			if(i != null) {
				if(sprite.collision(i))
					if(i.equals(soup)) {
						//System.out.println("Soup");
						if(sprite.getY() > i.getY())
							death();
						else if(sprite.getY() < i.getY())
							sprite.x_coordinate -= 10;

					}
					else if(i.equals(syrup)) {
						//System.out.println("Syrup");
						sprite.setX_coordinate(sprite.getX_coordinate()-2);

					}
					else if(i.equals(whisk)) {
						//System.out.println("Whisk");
						whiskMove = false;
						sprite.setY_coordinate(sprite.getY_coordinate()-8);
						groundLevel-=8;

					}
					else if(i.imagepath == "images/objects/Tomato.png") {
						tomato = true;
						movingTomato = i;
						tomatoCounter++;

					}
			}
		}

		if(tomato) {
			movingTomato.x_coordinate += (handPoint[0]-movingTomato.x_coordinate)/42;
			movingTomato.y_coordinate += (handPoint[1]-movingTomato.y_coordinate)/42;

		}




		if(sprite.getY() < 432 && whiskMove == true) {
			sprite.setY_coordinate(sprite.getY()+10);
		}

		if(move) {
			background1.move(1);
			background2.move(1);

			counter1.move(0);
			counter2.move(0);

			for(Item i: items)
				if(i != null)
					i.move(this);
		}



		for(int i = items.size()-1; i >= 0; i--) {
			if(items.get(i) != null && items.get(i).getX() <= 0) {
				items.remove(i);
			}
		}


		this.repaint();
	}

	// method: keyPressed()
	// description: This method is called when a key is pressed. You can determine which key is pressed using the 
	//				KeyEvent object.  For example if(e.getKeyCode() == KeyEvent.VK_LEFT) would test to see if
	//				the left key was pressed.
	// parameters: KeyEvent e
	@Override
	public void keyPressed(KeyEvent e) {


		if(e.getKeyCode() == KeyEvent.VK_SPACE && gameScreen != 2 && sprite.getY() == groundLevel && gameScreen != 4) {
			System.out.println("hello");
			sprite.jump();
			gameScreen = 3;
		}
		if(e.getKeyCode() == KeyEvent.VK_LEFT) {
			sprite.walkLeft();
		}
		if(e.getKeyCode() == KeyEvent.VK_RIGHT) {
			sprite.walkRight();
		}
		else if(gameScreen == 2)
			gameScreen = 3;
		if(e.getKeyCode() == KeyEvent.VK_0)
			gameScreen = 3;

		if(e.getKeyCode() == KeyEvent.VK_0) {
			items.get(items.size()-1).getX();
		}






	}

	// This function will play the sound "fileName".
	public static void playSound(String fileName) {
		try {
			File url = new File(fileName);
			Clip clip = AudioSystem.getClip();

			AudioInputStream ais = AudioSystem.getAudioInputStream(url);
			clip.open(ais);
			clip.start();
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
	}

	// method: keyTyped()
	// description: This method is called when a key is pressed and released. It basically combines the keyPressed and
	//              keyReleased functions.  You can determine which key is typed using the KeyEvent object.  
	//				For example if(e.getKeyCode() == KeyEvent.VK_LEFT) would test to see if the left key was typed.
	//				You probably don't want to do much in this method, but instead want to implement the keyPresses and keyReleased methods.
	// parameters: KeyEvent e
	@Override
	public void keyTyped(KeyEvent e) {



	}

	// method: keyReleased()
	// description: This method is called when a key is released. You can determine which key is released using the 
	//				KeyEvent object.  For example if(e.getKeyCode() == KeyEvent.VK_LEFT) would test to see if
	//				the left key was pressed.
	// parameters: KeyEvent e
	@Override
	public void keyReleased(KeyEvent e) {
		
		 if(e.getKeyCode() ==  KeyEvent.VK_SPACE)
			sprite.slowDown();

	}

	public void death() {
		timer.stop();
		gameScreen = 4;
		this.repaint();
	}
	public void fixPosition() {
		if(sprite.y_coordinate >432 && sprite.y_coordinate <= 450) {
			sprite.setY_coordinate(432);
			groundLevel = 432;
		}
		if(sprite.jumpCounter == -1 && sprite.x_coordinate > 900)
			sprite.x_coordinate-=3;
	}
	public boolean touching() {
		for(Item i:items) {
			if(sprite.collision(i) && i.equals(whisk))
				return true;
		}
		return false;
	}

}
